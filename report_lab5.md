# Отчёт по лабораторной работе №5  
**Тема**: Отладка кодовой базы проекта «Библиотека»  

---

## Цель работы

1. Скопировать рабочую реализацию лабораторной работы №4.  
2. Намеренно внести не менее 5 типовых логических или runtime-ошибок.  
3. Воспроизвести каждую ошибку.  
4. Найти и проанализировать ошибки с использованием отладчика (точки останова, пошаговое выполнение, анализ стека вызовов и локальных переменных).  
5. Исправить ошибки.  
6. Оформить отчёт с подробным описанием каждой ошибки.

---

## Описание проекта

Проект представляет собой симуляцию библиотеки, включающую:
- Классы предметной области: `Book`, `EBook`, `Audiobook`, `Library`.
- Пользовательские коллекции: `BookCollection` (списковая, через композицию), `IndexDict` (словарная, с индексацией по ISBN, автору, году).
- Функцию симуляции `run_simulation(steps, seed)`, выполняющую случайные события.

Версия для отладки (`lab5_buggy_library/`) содержит 5 специально внесённых ошибок.

---

## Ошибка 1 — Ошибка на единицу при удалении книги

### Место ошибки
Файл: `collections/book_collection.py`  
Метод: `remove`  
Строка:  
```python
return self._books.pop(i + 1)
```

### Воспроизведение
Создаём библиотеку, добавляем одну книгу, пытаемся её удалить:
```python
from models.book import Book
from models.library import Library

lib = Library()
b = Book("Тест", "Автор", 2020, "Жанр", "1")
lib.add_book(b)
lib.remove_book("1")  # Выбрасывает IndexError
```

### Анализ с помощью отладчика

Установлена точка останова на строке return self._books.pop(i + 1).
При выполнении:

    Локальные переменные:
```python 
i = 0
len(self._books) = 1
isbn = "1"
```
    Стек вызовов:
```python
BookCollection.remove() at book_collection.py:35
Library.remove_book() at library.py:16
<module> at test.py:6
```

Оператор pop(i + 1) пытается удалить элемент с индексом 1, но в списке длины 1 допустим только индекс 0.
### Причина

Ошибка на единицу: использование i + 1 вместо i при вызове list.pop().
### Исправление

Заменить строку:
```python
return self._books.pop(i + 1)
```
на:
```python 
return self._books.pop(i)
```

### Проверка

После исправления:

    Удаление единственной книги проходит без ошибок.
    Удаление книг из середины и начала списка также работает корректно.
    Тестовый сценарий завершается успешно.

## Ошибка 2 — Изменение коллекции во время итерации

### Место ошибки

Файл: `collections/index_dict.py`
Метод: `_remove_from_index`
Фрагмент:
```python 
for book_set in self._by_author.values():
    if book in book_set:
        book_set.remove(book)
        break
```

### Воспроизведение

    Добавить две книги одного автора.  
    Удалить одну из них.  
    Повторять до появления RuntimeError.

### Анализ с помощью отладчика

Точка останова установлена внутри тела цикла, на строке book_set.remove(book).

    Локальные переменные:
        book_set ссылается на множество из self._by_author.values().
        self._by_author.values() возвращает view, связанный с исходными множествами.
    Стек вызовов:
```python
IndexDict._remove_from_index() at index_dict.py:22
IndexDict.remove() at index_dict.py:38
Library.remove_book() at library.py:17
```

### Причина

Python запрещает изменять коллекцию, по которой идёт итерация. Метод dict.values() возвращает динамический view, и модификация исходных данных во время итерации приводит к неопределённому поведению.

### Исправление

Заменить итерацию на доступ по ключу:
```python
author_set = self._by_author.get(book.author)
if author_set:
    author_set.discard(book)
    if not author_set:
        del self._by_author[book.author]
```
Аналогично для _by_year.

### Проверка

    После исправления RuntimeError больше не возникает ни при каких сценариях.  
    Удаление книг с одинаковыми авторами/годами работает корректно.  
    Индексы остаются согласованными с коллекцией.

## Ошибка 3 — Использование изменяемого значения по умолчанию

### Место ошибки

Файл: `collections/book_collection.py`
Метод: `__init__`
Строка:  
```python 
def __init__(self, books: List[Book] = []):
```

### Воспроизведение
```python
c1 = BookCollection()
c2 = BookCollection()
b = Book("X", "A", 2020, "F", "X")
c1.add(b)
print(len(c2))  # Выводит 1, ожидается 0
```

### Анализ с помощью отладчика

Точка останова в __init__.

    Локальные переменные при создании c1 и c2:
        id(books) одинаков в обоих вызовах.
    Проверка в консоли отладчика:
```python
id(c1._books) == id(c2._books)  # True
```
Значение по умолчанию [] вычисляется один раз при определении функции, а не при каждом вызове.

### Причина

В Python аргументы по умолчанию вычисляются в момент определения функции, а не её вызова. Для изменяемых объектов (списки, словари, множества) это приводит к совместному использованию одного объекта.

### Исправление

Заменить на:
```python
def __init__(self, books: List[Book] = None):
    self._books = books or []
```

### Проверка
```python
c1 = BookCollection()
c2 = BookCollection()
print(id(c1._books) == id(c2._books))  # False
c1.add(b)
print(len(c2))  # 0 — корректно
```

## Ошибка 4 — Сравнение через is вместо in

### Место ошибки

Файл: `simulation.py`
Событие `"обновить_индекс"`, строка:
```python
if dummy_isbn is library.index._by_isbn:
```

### Воспроизведение

Добавить в код:
```python
isbn = "123"
index_dict = {"123": book}
print(isbn is index_dict)   # False
print(isbn in index_dict)   # True
```

### Анализ с помощью отладчика

Точка останова на строке условия.

    Локальные переменные:
        dummy_isbn = "dummy" (тип str)
        library.index._by_isbn — словарь (тип dict)
    Проверка: type(dummy_isbn) != type(library.index._by_isbn)

Оператор is проверяет идентичность объектов (равенство ссылок), а не логическое содержание.

### Причина
Непонимание различия между is (физическая идентичность) и in (логическое вхождение). Ошибка часто возникает при проверке наличия ключа в словаре.

### Исправление

Удалить бессмысленную проверку. Если требуется проверить наличие ISBN в индексе — использовать:
```python
if dummy_isbn in library.index._by_isbn:
```

### Проверка
После замены условие работает корректно: True, если ISBN есть в индексе, иначе False.

## Ошибка 5 — Ошибка состояния: глобальный флаг не сбрасывается

### Место ошибки

Файл: `simulation.py`
Глобальная переменная и её использование:
```python
index_rebuilt = False

def run_simulation(...):
    global index_rebuilt
    ...
    if index_rebuilt:
        print("Пропуск")
        continue
    ...
    index_rebuilt = True
```

### Воспроизведение

Файл main_buggy.py:
```python
run_simulation(steps=5, seed=1)
run_simulation(steps=5, seed=1)  # Второй запуск пропускает "обновить_индекс"
```

### Анализ с помощью отладчика

Точка останова на строке if index_rebuilt: во втором вызове.

    Глобальные переменные (через вкладку Globals):
        index_rebuilt = True (осталось от первого вызова)
    Стек вызовов:
```python
run_simulation() at simulation.py:85
<module> at main_buggy.py:7
```

### Причина

Глобальные переменные сохраняют своё значение в течение жизни модуля. Флаг index_rebuilt устанавливается в True и никогда не сбрасывается.

### Исправление

Сделать флаг локальной переменной:
```python
def run_simulation(steps: int = 20, seed: int | None = None) -> None:
    index_rebuilt = False  # <- локальная переменная
    if event == "обновить_индекс":
        if index_rebuilt:
            print("Пропуск (в рамках одной симуляции)")
            continue
        # перестройка индекса
        index_rebuilt = True
```

### Проверка

После исправления:

    Оба вызова run_simulation(steps=5, seed=1) дают идентичный вывод.  
    Событие "обновить_индекс" выполняется в обоих запусках при совпадении случайного выбора.
